import matplotlib.pyplot as plt
import numpy as np
import random
from itertools import product
from matplotlib.patches import Rectangle

map_width = 16
map_height = 16

#Bei Dynamic Environment darf nicht hardcoded sein
c_obs = np.array([(2,6), (2,7), (2,8), (2,9),(3,5),(3,6), (3,7), (3,8), (3,9),(3,10),(4,5),(4,6), (4,7), (4,8), (4,9),(4,10),(5,6), (5,7), (5,8), (5,9),
         (6,1), (6,2), (6,3),(7,0),(7,1), (7,2), (7,3),(7,4),(8,0),(8,1), (8,2), (8,3), (8,4), (9,1), (9,2), (9,3),
         (9,14), (9,13), (9,12), (9,11),(10,15),(10,14), (10,13), (10,12), (10,11), (10,10),(11,15),(11,14), (11,13), (11,12), (11,11), (11,10),(12,14), (12,13), (12,12), (12,11), 
         (12,3), (12,4), (12,5), (12,6),(13,2), (13,3), (13,4), (13,5), (13,6),(13,7),(14,2),(14,4), (14,5), (14,3), (14,6), (14,7), (15,3), (15,4), (15,5), (15,6)])
obstacle1 = np.array([(2,6), (2,7), (2,8), (2,9),(3,5),(3,6), (3,7), (3,8), (3,9),(3,10),(4,5),(4,6), (4,7), (4,8), (4,9),(4,10),(5,6), (5,7), (5,8), (5,9)])
obstacle2 = np.array([(6,1), (6,2), (6,3),(7,0),(7,1), (7,2), (7,3),(7,4),(8,0),(8,1), (8,2), (8,3), (8,4), (9,1), (9,2), (9,3)])
obstacle3 = np.array([(9,14), (9,13), (9,12), (9,11),(10,15),(10,14), (10,13), (10,12), (10,11), (10,10),(11,15),(11,14), (11,13), (11,12), (11,11), (11,10),(12,14), (12,13), (12,12), (12,11)])
obstacle4 = np.array([(12,3), (12,4), (12,5), (12,6),(13,2), (13,3), (13,4), (13,5), (13,6),(13,7),(14,2),(14,4), (14,5), (14,3), (14,6), (14,7), (15,3), (15,4), (15,5), (15,6)])

obstacle_list = [obstacle2,obstacle3,obstacle4]

#check if value of map coordinate equals 0 
#obstacle check if obstacle new point gets created
def is_feasible(point1, point2, obstacle_list):   
    # Überprüfen, ob der Weg von point1 zu point2 durch ein Hindernis geht
    for obstacle in obstacle_list:
        if intersects(point1, point2, obstacle):
            return False
    
    # Überprüfen, ob point1 innerhalb eines Hindernisses liegt
    for obstacle in obstacle_list:
        if pointInsideObstacle(point1, obstacle):
            return False
        
    return True

def intersects(point1, point2, obstacle):
    # Überprüfen, ob die Strecke von point1 zu point2 das Hindernis schneidet
        x_min = min(point1[0], point2[0])
        x_max = max(point1[0], point2[0])
        y_min = min(point1[1], point2[1])
        y_max = max(point1[1], point2[1])

        for obs in obstacle:
            if obs[0] >= x_min and obs[0] <= x_max and obs[1] >= y_min and obs[1] <= y_max:
                return True
        return False

def pointInsideObstacle(point, obstacle):
    # Überprüfen, ob der Punkt innerhalb des Hindernisses liegt
    for obs in obstacle:
        if point[0] == obs[0] and point[1] == obs[1]:
            return True
    
    return False

#t werden und speichere die getroffenen Punkte damit der Algorithmus weiß,
# bei welchen Punkten er direkt abbrechen kann. Idee: aufrunden und abrunden ob auf dem Punkt der Ganzzahl ein Hindernis ist

def evaluate_path(path):
    x_points = []
    y_points= []
    for i in range(len(path)):
        x, y = path[i]
        x_points.append(x)
        y_points.append(y)
    i=1
    total_distance= 0
    while i < len(path)-1:
        total_distance += np.sqrt((x_points[i+1] - x_points[i])**2 + (y_points[i+1] - y_points[i])**2)
        i+=1
    return total_distance
    
            
#each bee is one path, each path consists of k points
# new point is generated by randomly producing x and y coordinates by using the uniform distribution
#now add start and destination points
def initPopulation():
    k=7
    xs = (0)
    xe = (16)
    ys = (0)
    ye = (2*k)
    i = 1
    path = [(xs,ys)]
    goal = (16,16)
    while i < k-2:
        x = int(random.uniform(0, map_width))
        y = int(random.uniform(0, map_height))
        position = (x,y)
        if is_feasible(position, path[i-1],obstacle_list=obstacle_list):
            path.append((x,y))
            i+=1

        else:
            while not is_feasible(position,path[i-1],obstacle_list=obstacle_list):
                if is_feasible(position, path[i-1],obstacle_list=obstacle_list):
                    path.append((xe,ye))
                    i+=1
                else:
                    x = int(random.uniform(0, map_width))
                    y = int(random.uniform(0, map_height))
                    position = (x,y)

    count = 0

    while not is_feasible(goal,path[i-1],obstacle_list=obstacle_list):
         count += 1
         x = int(random.uniform(0, map_width))
         y = int(random.uniform(0, map_height))
         if is_feasible((x,y), path[i-2], obstacle_list=obstacle_list):
             path[i-1] = (x,y)
         if count > 10:
             return initPopulation()   
         
    
    path.append(goal)
    return  path
    
def path_is_feasible(path):
    i=1
    while i < len(path):
        if not is_feasible(path[i], path[i-1],obstacle_list=obstacle_list):
            i+=1
            return False
        else:
            i+=1
    return True

def local_search(solution, fitness):
    ngh = 2
    i = 1
    while i <= len(solution) - 2:
        count= 0
        new_solution = solution.copy()
        new_point =  (int(random.uniform(solution[i][0]-ngh, solution[i][0]+ngh)),int(random.uniform(solution[i][1]-ngh, solution[i][1]+ngh)))
        new_solution[i] = new_point
        while not path_is_feasible(new_solution):
           new_point =  (int(random.uniform(solution[i][0]-ngh, solution[i][0]+ngh)),int(random.uniform(solution[i][1]-ngh, solution[i][1]+ngh)))
           new_solution[i] = new_point 
           count +=1
           if count > 20:
               return solution
        new_fitness = evaluate_path(new_solution)
        if new_fitness < fitness:
            solution = new_solution
        i+= 1
    return solution

#Schaut ob Pfad beste Lösung, wenn nicht dann wird einer zufällige Änderungen an einer ausgewählten Stelle
def generate_new_solutions(solutions, best_solution):
    new_solutions = []
    for solution in solutions:
        # Wenn die Lösung mit der besten Lösung übereinstimmt, wird sie übersprungen
        if solution == best_solution:
            continue
        
        # Zufällige Stelle im Pfad auswählen
        index = random.randint(1, len(solution)-2)
        
        # Neue Lösung generieren durch zufällige Änderung an der ausgewählten Stelle
        new_solution = solution.copy()
        new_x = new_solution[index][0] 
        new_y = new_solution[index][1] 
        new_solution[index] = (new_x, new_y)
        
        # Neue Lösung zur Lösungsmenge hinzufügen
        new_solutions.append(new_solution)
    
    return new_solutions

def plot_path_with_obstacles(path, obstacles):
    fig, ax = plt.subplots()
    for obstacle in obstacles:
        # Find the corners of the rectangle
        min_x = np.min(obstacle[:,0])
        max_x = np.max(obstacle[:,0])
        min_y = np.min(obstacle[:,1])
        max_y = np.max(obstacle[:,1])
        width = max_x - min_x
        height = max_y - min_y
        # Draw the rectangle
        rect = plt.Rectangle((min_x, min_y), width, height, facecolor='gray')
        ax.add_patch(rect)
    # Plot the path
        path_x = [point[0] for point in path]
        path_y = [point[1] for point in path]
        ax.plot(path_x, path_y, 'bo-')
        ax.plot(0,0, 'r')
        ax.plot(16,16, 'r') 

    ax.set_aspect('equal')
    plt.show()
    
def plot_paths_with_obstacles(paths, obstacles):
    fig, ax = plt.subplots()
    for obstacle in obstacles:
        # Find the corners of the rectangle
        min_x = np.min(obstacle[:,0])
        max_x = np.max(obstacle[:,0])
        min_y = np.min(obstacle[:,1])
        max_y = np.max(obstacle[:,1])
        width = max_x - min_x
        height = max_y - min_y
        # Draw the rectangle
        rect = plt.Rectangle((min_x, min_y), width, height, facecolor='gray')
        ax.add_patch(rect)
    # Plot the path
    for path in paths:
        path_x = [point[0] for point in path]
        path_y = [point[1] for point in path]
        ax.plot(path_x, path_y, 'bo-')
        ax.plot(0,0, 'r')
        ax.plot(16,16, 'r')

    ax.set_aspect('equal')
    plt.show()

def bees_algorithm(num_scouts):
    i=0
    solutions = []
    while i <= num_scouts:    
        path = initPopulation()
        solutions.append(path)
        i+=1
    print("population initialisiert")
    for i in range(num_scouts):
        # Führe Local Search für jede Lösung durch
        for j in range(len(solutions)):
            solutions[j] = local_search(solutions[j], evaluate_path(solutions[j]))
        print("Local Search durchgeführt")
        # Berechne Fitness-Werte der Lösungen
        fitnesses = [evaluate_path(solution) for solution in solutions]
        print("Fitness errechnet")
        # Aktualisiere die beste Lösung (findet niedrigsten Wert im Array)
        best_solution_index = np.argmin(fitnesses)
        best_solution = solutions[best_solution_index]

        # Generiere neue Lösungen durch den Bee Dance
        new_solutions = generate_new_solutions(solutions, best_solution)

        # Sortiere Array aufsteigend
        fitnesses = sorted(fitnesses)

        # Aktualisiere die Lösungsmenge mit den neuen Lösungen
        solutions[num_scouts:] = new_solutions
        print("best-path:")
        print(evaluate_path(best_solution))

    return solutions, best_solution

solutions, best_path = bees_algorithm(10)
print(path_is_feasible(best_path))
print(best_path)
plot_path_with_obstacles(best_path, obstacle_list)
plot_paths_with_obstacles(solutions, obstacle_list)